module Queens where

import Data.List ((\\))

-- DFS find 92 distinct solutions
solve = dfsSolve [[]] [] where
    dfsSolve [] s = s
    dfsSolve (c:cs) s
             | length c == 8 = dfsSolve cs (c:s)
             | otherwise = dfsSolve ([(x:c) | x <- [1..8] \\ c, not $ attack x c] ++ cs) s
    attack x cs = let y = 1 + length cs in 
                 any (\(c, r) -> abs(x - c) == abs(y - r)) $ zip (reverse cs) [1..]


-- TODO: constructive find 12 unique solutions (not remove duplicates, but avoid duplicate)
-- One idea is to limit the queue in the 1st row within half, which generate 46 solutions,
-- While there are still solutions can be generated by rotating in other angles (and flip)
